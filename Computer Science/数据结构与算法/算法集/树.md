# æ ‘

# åŸºæœ¬æ¦‚å¿µ

â€‹![image](assets/image-20241108100018-dh7gduc.png)â€‹

* æ ‘
* æ ¹
* å­æ ‘
* å­ç»“ç‚¹
* çˆ¶ç»“ç‚¹
* ç»“ç‚¹çš„åº¦ï¼šå­ç»“ç‚¹æˆ–éç©ºå­æ ‘çš„ä¸ªæ•°
* æ ‘çš„åº¦ï¼šmax{ç»“ç‚¹çš„åº¦}
* å¶ç»“ç‚¹ï¼šç»“ç‚¹çš„åº¦ä¸º0
* ä¸­é—´ç»“ç‚¹ï¼šç»“ç‚¹çš„åº¦ä¸ä¸º0
* å…„å¼Ÿç»“ç‚¹
* ç»“ç‚¹çš„å±‚æ¬¡ï¼šä»é¡¶å‘ä¸‹ï¼ˆä»0è¿˜æ˜¯ä»1å¼€å§‹ä¸ä¸€å®šï¼‰
* ç»“ç‚¹çš„é«˜åº¦ï¼šå¶ç»“ç‚¹é«˜åº¦ä¸º1ï¼Œä¸­é—´ç»“ç‚¹çš„é«˜åº¦ä¸ºæ‰€æœ‰å­ç»“ç‚¹æœ€å¤§é«˜åº¦ + 1
* ç»“ç‚¹çš„æ·±åº¦ï¼šè®°æ ¹ç»“ç‚¹çš„æ·±åº¦ä¸º1ï¼Œå‘ä¸‹é€’å¢
* æ ‘çš„é«˜åº¦ï¼ˆæ·±åº¦ï¼‰ï¼šæ ¹èŠ‚ç‚¹çš„é«˜åº¦
* æœ‰åºæ ‘ï¼šå·¦å³ç»“ç‚¹ä¸èƒ½äº¤æ¢é¡ºåº
* æ£®æ—ï¼šç‹¬ç«‹æ ‘çš„é›†åˆ

# äºŒå‰æ ‘

* æ»¡äºŒå‰æ ‘ **a full binary tree**ï¼šç”±åº¦ä¸º0çš„å¶ç»“ç‚¹å’Œåº¦ä¸º2çš„ä¸­é—´ç»“ç‚¹æ„æˆçš„äºŒå‰æ ‘ï¼Œæ ‘ä¸­æ²¡æœ‰åº¦ä¸º1çš„ç»“ç‚¹
* å®Œå…¨äºŒå‰æ ‘ **a complete tree**ï¼šå¯¹äºä¸€æ£µäºŒå‰æ ‘ï¼Œé™¤æœ€åä¸€å±‚å¤–ï¼Œå…¶ä»–å„å±‚çš„ç»“ç‚¹ä¸ªæ•°éƒ½è¾¾åˆ°æœ€å¤§ï¼Œæœ€åä¸€å±‚åˆ™å¯ä»å³å‘å·¦è¿ç»­ç¼ºè‹¥å¹²ä¸ªç»“ç‚¹ã€‚

  * æœ‰ *n* ä¸ªç»“ç‚¹çš„å®Œå…¨äºŒå‰æ ‘ï¼Œé«˜åº¦ä¸º$floor( log_{2}(n + 1) )$

  â€‹![image](assets/image-20241108100548-txajqec.png)â€‹
* å®Œç¾äºŒå‰æ ‘ï¼šæ¯ä¸€å±‚ç»“ç‚¹æ•°ç›®éƒ½è¾¾åˆ°äº†æœ€å¤§ã€‚

  â€‹![image](assets/image-20241108100534-aba31na.png)â€‹

## ç‰¹æ€§

* *n*â€‹*<sub>2</sub>*  = *n*â€‹*<sub>0</sub>* - 1
* ç¬¬ *i* å±‚æœ€å¤šæœ‰ï¼š2*<sup>i - 1</sup>* ä¸ªç»“ç‚¹
* æ·±åº¦ä¸º *d* çš„äºŒå‰æ ‘æœ€å¤šæœ‰ 2<sup>*d*</sup>  - 1ä¸ªç»“ç‚¹

## å­˜å‚¨æ–¹å¼

> é¡ºåºå­˜å‚¨

1. ç»“ç‚¹ç¼–å·ï¼šæ ‘æ ¹çš„ç´¢å¼•ä¸º1ï¼›è®¾ç»“ç‚¹çš„ç¼–å·ä¸ºğ‘˜ (ğ‘˜â‰¥1)

    1. å¦‚æœå…¶å·¦å­æ ‘éç©ºï¼Œåˆ™å·¦å­ç»“ç‚¹çš„ç¼–å·ä¸º2ğ‘˜
    2. å¦‚æœå³å­æ ‘éç©ºï¼Œåˆ™å³å­ç»“ç‚¹ä¸º2ğ‘˜+1
2. é¡ºåºå­˜æ”¾ï¼šç”¨ä¸€ç»„åœ°å€è¿ç»­çš„å­˜å‚¨å•å…ƒå­˜å‚¨äºŒå‰æ ‘çš„å„ä¸ªç»“ç‚¹ï¼Œä»¥æŸç§ç‰¹æ®Šçš„å€¼è¡¨ç¤ºä¸å­˜åœ¨çš„ç»“ç‚¹ã€‚

> é“¾æ¥å­˜å‚¨

```Java
class Node <Val> {
	Val value;
	Node left;
	Node right;
	(Node parent;)
}
```

## å½¢æ€è®¡æ•°

> ä¸åŒå½¢æ€äºŒå‰æ ‘è®¡æ•°

è®¾æœ‰nä¸ªç»“ç‚¹çš„ä¸åŒäºŒå‰æ ‘æ•°ç›®ä¸ºbnï¼Œé‚£ä¹ˆï¼š

* æŒ‘é€‰nä¸ªç»“ç‚¹ä¸­çš„æŸä¸€ä¸ªä½œä¸ºæ ¹ç»“ç‚¹ï¼Œ

  * *i*ï¼ˆ0 â‰¤ *i* â‰¤ n - 1ï¼‰æ˜¯æ ¹ç»“ç‚¹çš„å·¦å­æ ‘ä¸­ç»“ç‚¹çš„ä¸ªæ•°,
  * å‰©ä¸‹çš„(n - i - 1)ä¸ªç»“ç‚¹åœ¨æ ¹çš„å³å­æ ‘ä¸­ï¼Œ
* æ­¤æ—¶äºŒå‰æ ‘çš„æ•°ç›® b<sub>i</sub> * b<sub>n-i-1</sub>

  * b<sub>0</sub> = 1
  * b<sub>1</sub> = 1
  * b<sub>n</sub> = b<sub>0</sub>b<sub>n-1</sub> + b<sub>1</sub>b<sub>n-2</sub> +  â€¦ + b<sub>n-1</sub>b<sub>0</sub>

$$
b_{n} = \frac{C^{n}_{2n}}{(n + 1)}
$$

## æ£®æ—ä¸äºŒå‰æ ‘

â€‹![image](assets/image-20241105095749-dxkdj8u.png)â€‹

## åºåˆ—åŒ–å’Œååºåˆ—åŒ–

**åºåˆ—åŒ–**ï¼šæŒ‰æŸç§éå†æ–¹æ¡ˆè®¿é—®æ‰€æœ‰ç»“ç‚¹å¹¶ä¾æ¬¡è¾“å‡ºç»“ç‚¹æ•°æ®ï¼Œç”±æ­¤å½¢æˆç»“ç‚¹çš„çº¿æ€§åºåˆ—ï¼ˆå°†æ ‘çš„éçº¿æ€§ç»“æ„è½¬æ¢æˆçº¿æ€§ç»“æ„ï¼Œä¾¿äºä½¿ç”¨çº¿æ€§è¡¨æˆ–å­—ç¬¦ä¸²ç­‰å­˜å‚¨ï¼‰

**ååºåˆ—åŒ–**ï¼šæ ¹æ®çº¿æ€§åºåˆ—é‡æ„åŸå§‹çš„äºŒå‰æ ‘

### æŒ‰å±‚æ¬¡åºçš„é¡ºåºå­˜å‚¨

æŒ‰å±‚æ¬¡ä»ä¸Šåˆ°ä¸‹ã€æ¯ä¸€å±‚ä»å·¦åˆ°å³ä¾æ¬¡å­˜æ”¾åœ¨é¡ºåºå­˜å‚¨ç©ºé—´ï¼ˆå±‚æ¬¡éå†åºåˆ—ï¼‰ã€‚

1. å¦‚æœ 2k â‰¤ nï¼Œåˆ™ç»“ç‚¹ k çš„å·¦å­ç»“ç‚¹æ˜¯ 2kï¼Œå¦åˆ™æ²¡æœ‰å·¦å­ç»“ç‚¹ï¼›
2. å¦‚æœ 2k + 1 â‰¤ n ï¼Œåˆ™ç»“ç‚¹ k çš„å³å­ç»“ç‚¹æ˜¯2k + 1 ï¼Œå¦åˆ™æ²¡æœ‰å³å­ç»“ç‚¹ã€‚
3. å¦‚æœ k > 1ï¼Œåˆ™ç»“ç‚¹ k çš„çˆ¶ç»“ç‚¹æ˜¯ âŒŠk / 2âŒ‹ã€‚

## è¡¨è¾¾å¼è®¡ç®—

## å“ˆå¤«æ›¼æ ‘Huffman

å¯»æ‰¾å…·æœ‰æœ€å°åŠ æƒå¤–éƒ¨è·¯å¾„é•¿åº¦çš„äºŒå‰æ ‘

**Huffmanæ ‘**ï¼šç»™å®šä¸€ç»„å¶ç»“ç‚¹æƒé‡ï¼Œç”±æ­¤æ„å»ºçš„æ‰€æœ‰å¸¦æƒäºŒå‰æ ‘ä¸­ï¼Œå¸¦æƒè·¯å¾„é•¿åº¦æœ€å°çš„äºŒå‰æ ‘ç§°ä¸ºå“ˆå¤«æ›¼æ ‘ï¼Œåˆç§°ä¸º**æœ€ä¼˜äºŒå‰æ ‘**ã€‚

* Huffmanæ ‘çš„éå¶å­ç»“ç‚¹çš„åº¦å‡ä¸º2

  * ä¸ä¸€å®šæ˜¯æ»¡äºŒå‰æ ‘
* æƒé‡å°çš„å¶ç»“ç‚¹çš„å±‚æ¬¡**ä¸å°äº**æƒé‡å¤§çš„å¶ç»“ç‚¹

1. æ¯æ¬¡å–æœ€å°å’Œæ¬¡å°çš„ä¸¤ä¸ªå…ƒç´ ï¼Œcost += ä¸¤å…ƒç´ ä¹‹å’Œ
2. å†å°†ä¸¤å…ƒç´ ä¹‹å’Œæ”¾å…¥å®¹å™¨ä¸­ï¼Œé‡å¤æ­¥éª¤1

# éå†æ–¹å¼

å‰ååºéå†å¹¶ä¸ä»…é™äºäºŒå‰æ ‘ï¼Œåªè¦æ˜¯æœ‰åºæ ‘éƒ½å¯ä»¥ï¼›ä½†ä¸­åºéå†åªèƒ½åœ¨äºŒå‰æ ‘ä¸­

å¯¹äºæ™®é€šæ ‘ï¼Œå‰ååºéå†ç¡®å®šå³å¯å”¯ä¸€ç¡®å®šæ ‘ï¼›ä½†æ˜¯å¯¹äºäºŒå‰æ ‘ï¼Œåªæœ‰å‰ååºéå†ä¸èƒ½å”¯ä¸€ç¡®å®šæ ‘

* DFS

  * å‰åºéå†ï¼ˆé€’å½’æ³•ï¼Œè¿­ä»£æ³•ï¼‰
  * ä¸­åºéå†ï¼ˆé€’å½’æ³•ï¼Œè¿­ä»£æ³•ï¼‰
  * ååºéå†ï¼ˆé€’å½’æ³•ï¼Œè¿­ä»£æ³•ï¼‰
* BFS

  * å±‚æ¬¡éå†ï¼ˆè¿­ä»£æ³•ï¼‰

## å‰åºéå† Preorder Traversal

å…ˆè®¿é—®æ ¹ç»“ç‚¹ï¼Œå†é€’å½’è®¿é—®æ‰€æœ‰å­æ ‘

### é€’å½’

1. ç¡®å®šé€’å½’å‡½æ•°çš„å‚æ•°å’Œè¿”å›å€¼
2. ç¡®å®šç»ˆæ­¢æ¡ä»¶
3. ç¡®å®šå•å±‚é€’å½’çš„é€»è¾‘

```Java
import java.util.ArrayList;
import java.util.List;

class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        dfs(root, result);
        return result;
    }

    private void dfs(TreeNode cur, List<Integer> vec) {
        if (cur == null) {
            return;
        }

        vec.add(cur.val);
        dfs(cur.left, vec);
        dfs(cur.right, vec);
    }
}
```

### è¿­ä»£

è®¿é—®ç»“ç‚¹ + å¤„ç†ç»“ç‚¹

1. å…ˆå°†æ ¹èŠ‚ç‚¹è¾“å‡º
2. å°†å³å­ç»“ç‚¹æ”¾å…¥æ ˆä¸­
3. å°†å·¦å­ç»“ç‚¹æ”¾å…¥æ ˆä¸­
4. å‡ºæ ˆï¼Œé‡å¤

æ³¨æ„é¡ºåºï¼šæ ¹å·¦å³ã€‚æ‰€ä»¥åº”è¯¥å…ˆå°†å³å­ç»“ç‚¹æ”¾å…¥ï¼Œå†æ”¾å…¥å·¦å­ç»“ç‚¹ï¼›å‡ºæ ˆæ—¶å¯ä»¥å®ç°å·¦å­ç»“ç‚¹å…ˆå‡ºæ ˆï¼Œå³å­ç»“ç‚¹åå‡ºæ ˆ

```Java
import java.util.ArrayList;
import java.util.List;
import java.util.Stack;

class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        Stack<TreeNode> s = new Stack<>();

        s.push(root);
        while (!s.isEmpty()) {
            TreeNode cur = s.pop();
            if (cur == null) {
                continue;
            }
            result.add(cur.val);
            s.push(cur.right);
            s.push(cur.left);
        }
        return result;
    }
}
```

## ä¸­åºéå† Inorder Traversal

åªåœ¨äºŒå‰æ ‘ä¸­å­˜åœ¨è¿™ç§éå†æ–¹æ³•ï¼Œå…ˆè®¿é—®å·¦å­ç»“ç‚¹ï¼Œå†è®¿é—®æ ¹ç»“ç‚¹ï¼Œæœ€åè®¿é—®å³å­ç»“ç‚¹

### é€’å½’

```Java
import java.util.ArrayList;
import java.util.List;

class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        dfs(root, result);
        return result;
    }

    private void dfs(TreeNode cur, List<Integer> vec) {
        if (cur == null) {
            return;
        }

        dfs(cur.left, vec);
        vec.add(cur.val);
        dfs(cur.right, vec);
    }
}
```

### è¿­ä»£

è®¿é—®ç»“ç‚¹ + å¤„ç†ç»“ç‚¹ï¼Œä¸¤è€…é¡ºåºä¸åŒäº†

è¦ä½¿ç”¨æ ˆæ¥è®°å½•éå†é¡ºåº

1. ä»æ ¹ç»“ç‚¹å¼€å§‹ï¼Œä¸€è·¯å‘å·¦ï¼Œéç©ºç»“ç‚¹å…¥æ ˆ
2. å½“é‡åˆ°äº†ç©ºç»“ç‚¹ï¼ˆä¸ç®¡æ˜¯å‘å·¦æ‰¾è¿˜æ˜¯å‘å³æ‰¾ï¼‰ï¼Œæ­¤æ—¶æ ˆé¡¶ç»“ç‚¹æ˜¯æœ€è¿‘è®¿é—®è¿‡çš„ç»“ç‚¹ï¼Œæ‰€ä»¥å‡ºæ ˆï¼Œå¹¶ç»§ç»­è®¿é—®è¿™ä¸ªç»“ç‚¹çš„å³ç»“ç‚¹

```Java
import java.util.List;
import java.util.ArrayList;
import java.util.Stack;

class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        Stack<TreeNode> s = new Stack<>();
        TreeNode cur = root;
  
        while (cur != null || !s.isEmpty()) {
            if (cur != null) {
                s.push(cur);
                cur = cur.left;			// å·¦
            } else {	// å¦‚æœè¿›å…¥åˆ°è¿™é‡Œï¼Œè¯´æ˜cur == nullä¸”sä¸ä¸ºç©º
                cur = s.pop();
                result.add(cur.val);	// ä¸­
                cur = cur.right;		// å³
            }
        }
        return result;
    }
}
```

## ååºéå† Postorder Traversal

å…ˆé€’å½’è®¿é—®æ‰€æœ‰å­æ ‘ï¼Œå†è®¿é—®æ ¹ç»“ç‚¹

### é€’å½’

```Java
import java.util.ArrayList;
import java.util.List;

class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        dfs(root, result);
        return result;
    }

    private void dfs(TreeNode cur, List<Integer> vec) {
        if (cur == null) {
            return;
        }

        dfs(cur.left, vec);
        dfs(cur.right, vec);
        vec.add(cur.val);
    }
}
```

### è¿­ä»£

1. äº¤æ¢å·¦å³ç»“ç‚¹çš„å…¥æ ˆé¡ºåºï¼šæ ¹å·¦å³ -> æ ¹å³å·¦
2. åè½¬æ•°ç»„ï¼šæ ¹å³å·¦ -> å·¦å³æ ¹

```Java
import java.util.ArrayList;
import java.util.List;
import java.util.Stack; 
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        Stack<TreeNode> s = new Stack<>();

        s.push(root);
        while (!s.isEmpty()) {
            TreeNode cur = s.pop();
            if (cur == null) {
                continue;
            }
            result.add(cur.val);
            s.push(cur.left);
            s.push(cur.right);
        }  

        reverse(result);
        return result;
    }

    private void reverse(List<Integer> list) {
        for (int i = 0, j = list.size() - 1; i < j; i++, j--) {
            int temp = list.get(i);		// get(index)
            list.set(i, list.get(j));	// set(index, value)
            list.set(j, temp);
        }
    }
}
```

## å±‚åºéå†

æ ¹æ®å±‚æ¬¡é€’å¢è®¿é—®ï¼Œä»æ ¹ç»“ç‚¹å¼€å§‹ï¼Œä»ä¸Šè‡³ä¸‹æŒ‰å±‚è®¿é—®æ¯ä¸ªç»“ç‚¹ï¼Œå¹¶ä¸”æ¯å±‚ç»“ç‚¹æŒ‰ç…§ä»å·¦åˆ°å³çš„é¡ºåºè¿›è¡Œå¤„ç†

1. ä½¿ç”¨é˜Ÿåˆ—ï¼Œå®ç°BFS
2. å¦‚æœåªè¦æ±‚æŒ‰é¡ºåºè¾“å‡ºï¼Œå°±ä¸éœ€è¦äºŒç»´æ•°ç»„äº†ï¼›ä½†æ˜¯æœ‰æ—¶éœ€è¦åŒºåˆ†å„å±‚å…ƒç´ ï¼Œå¯ä»¥ä½¿ç”¨äºŒç»´æ•°ç»„æ¥å­˜æ”¾

### åˆ†å±‚å­˜å‚¨

[leetcode.cn/problems/binary-tree-level-order-traversal/submissio...](https://leetcode.cn/problems/binary-tree-level-order-traversal/submissions/580569032/)

```Java
import java.util.List;
import java.util.ArrayList;
import java.util.Queue;
import java.util.LinkedList;

class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> result = new ArrayList<>();
        if (root == null) {
            return result;
        }

        Queue<TreeNode> q = new LinkedList<>();
        q.add(root);
        int size; // è®°å½•æ¯ä¸€å±‚æœ‰å¤šå°‘ä¸ªå…ƒç´ ï¼Œç”¨æ¥å†³å®šé˜Ÿåˆ—æ¯æ¬¡è¦å¼¹å‡ºå¤šå°‘ä¸ªå…ƒç´ 
        while (!q.isEmpty()) {
            size = q.size();
            List<Integer> vec = new ArrayList<>();
            while (size > 0) {
                size--;
                TreeNode cur = q.remove();
                vec.add(cur.val);
                if (cur.left != null) {
                    q.add(cur.left);
                }
                if (cur.right != null) {
                    q.add(cur.right);
                }
            }
            result.add(vec);
        }
        return result;
    }
}
```

### é”¯é½¿çŠ¶åˆ†å±‚éå†

# éå†åº”ç”¨

## äºŒå‰æ ‘çš„æ‰€æœ‰è·¯å¾„

[leetcode.cn/problems/binary-tree-paths/description/](https://leetcode.cn/problems/binary-tree-paths/description/)

> ç»™ä½ ä¸€ä¸ªäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ `root`â€‹ ï¼ŒæŒ‰ **ä»»æ„é¡ºåº** ï¼Œè¿”å›æ‰€æœ‰ä»æ ¹èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹çš„è·¯å¾„ã€‚
>
> **å¶å­èŠ‚ç‚¹** æ˜¯æŒ‡æ²¡æœ‰å­èŠ‚ç‚¹çš„èŠ‚ç‚¹ã€‚

å‰åºéå†ï¼šè¦å¸¦ç€å½“å‰ç»“ç‚¹çš„ä¿¡æ¯éå†å­ç»“ç‚¹

```Java
import java.util.List;
import java.util.ArrayList;
class Solution {
    private List<String> results;
    public List<String> binaryTreePaths(TreeNode root) {
        results = new ArrayList<>();
        dfs(root, new ArrayList<>());
        return results;
    }

    private void dfs(TreeNode cur, List<Integer> arr) {
        if (cur.left == null && cur.right == null) {
            StringBuilder sb = new StringBuilder();
            for (int i = 0; i < arr.size(); i++) {
                sb.append(arr.get(i));
                sb.append("->");
            }
			// å½“å‰ç»“ç‚¹ä¸è¦å¿˜è®°å¤„ç†
            sb.append(cur.val);
            results.add(sb.toString());
            return;
        }

        arr.add(cur.val);
        if (cur.left != null) {
            dfs(cur.left, arr);
        }
        if (cur.right != null) {
            dfs(cur.right, arr);
        }
        arr.remove(arr.size() - 1);
    }
}
```

## è·¯å¾„æ€»å’Œ

[leetcode.cn/problems/path-sum/](https://leetcode.cn/problems/path-sum/)

> ç»™ä½ äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ `root`â€‹ å’Œä¸€ä¸ªè¡¨ç¤ºç›®æ ‡å’Œçš„æ•´æ•° `targetSum`â€‹ ã€‚åˆ¤æ–­è¯¥æ ‘ä¸­æ˜¯å¦å­˜åœ¨ **æ ¹èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹** çš„è·¯å¾„ï¼Œè¿™æ¡è·¯å¾„ä¸Šæ‰€æœ‰èŠ‚ç‚¹å€¼ç›¸åŠ ç­‰äºç›®æ ‡å’Œ `targetSum`â€‹ ã€‚å¦‚æœå­˜åœ¨ï¼Œè¿”å› `true`â€‹ ï¼›å¦åˆ™ï¼Œè¿”å› `false`â€‹ã€‚

ä¼˜åŒ–ï¼š

1. sumå¯ä»¥ä¼ å…¥targetSumï¼Œè¿›è¡Œå‡æ“ä½œ
2. å¯¹resultè¿›è¡Œåˆ¤æ–­ï¼Œææ—©ç»“æŸé€’å½’

```Java
import java.util.List;
import java.util.ArrayList;
class Solution {
    public boolean hasPathSum(TreeNode root, int targetSum) {
        if (root == null) {
            return false;
        }
        return getPath(root, targetSum - root.val);
    }

    private boolean getPath(TreeNode cur, int target) {
        if (cur.left == null && cur.right == null) {
            if (0 == target) {
                return true;
            }
            return false;
        }
        if (cur.left != null) {
            if (getPath(cur.left, target - cur.left.val)) {
                return true;
            }
        }
        if (cur.right != null) {
            if (getPath(cur.right, target - cur.right.val)) {
                return true;
            }
        }
        return false;
    }
}
```

[leetcode.cn/problems/path-sum-ii/description/](https://leetcode.cn/problems/path-sum-ii/description/)

> æ‰¾è·¯å¾„
>
> ç»™ä½ äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ `root`â€‹ å’Œä¸€ä¸ªæ•´æ•°ç›®æ ‡å’Œ `targetSum`â€‹ ï¼Œæ‰¾å‡ºæ‰€æœ‰ **ä»æ ¹èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹** è·¯å¾„æ€»å’Œç­‰äºç»™å®šç›®æ ‡å’Œçš„è·¯å¾„ã€‚

```Java
import java.util.List;
import java.util.ArrayList;
class Solution {
    private int target;
    private List<List<Integer>> results;
    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
        results = new ArrayList<>();
        target = targetSum;
        getPath(root, 0, new ArrayList<>());
        return results;
    }

    private void getPath(TreeNode cur, int sum, List<Integer> path) {
        if (cur == null) {
            return;
        }

        sum += cur.val;
        path.add(cur.val);
        if (cur.left == null && cur.right == null) {
            if (sum == target) {
                results.add(new ArrayList(path));
            }
            path.remove(path.size() - 1);
            return;
        }
        getPath(cur.left, sum, path);
        getPath(cur.right, sum, path);
        path.remove(path.size() - 1);
    }
}
```

## å·¦å¶å­ä¹‹å’Œ

[leetcode.cn/problems/sum-of-left-leaves/description/](https://leetcode.cn/problems/sum-of-left-leaves/description/)

> ç»™å®šäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ `root`â€‹ ï¼Œè¿”å›æ‰€æœ‰å·¦å¶å­ä¹‹å’Œã€‚

```Java
class Solution {
    public int sumOfLeftLeaves(TreeNode root) {
        return getSum(root);
    }

    private int getSum(TreeNode cur) {
        if (cur == null) {
            return 0;
        }
        if (cur.left == null && cur.right == null) {
            return  0;
        }
        // é¦–å…ˆè¦æ˜¯å¶å­ç»“ç‚¹ï¼Œå†æ˜¯å·¦å¶å­ï¼Œéœ€è¦é€šè¿‡çˆ¶ç»“ç‚¹åˆ¤æ–­
        int result = getSum(cur.left);
        if (cur.left != null && cur.left.left == null && cur.left.right == null) {
            result = cur.left.val;
        }
        if (cur.right != null) {
            result += getSum(cur.right);
        }
        return result;
    }
}
```

## æ‰¾æ ‘å·¦ä¸‹è§’çš„å€¼

[leetcode.cn/problems/find-bottom-left-tree-value/description/](https://leetcode.cn/problems/find-bottom-left-tree-value/description/)

> ç»™å®šä¸€ä¸ªäºŒå‰æ ‘çš„ **æ ¹èŠ‚ç‚¹** `root`â€‹ï¼Œè¯·æ‰¾å‡ºè¯¥äºŒå‰æ ‘çš„ **æœ€åº•å±‚ æœ€å·¦è¾¹** èŠ‚ç‚¹çš„å€¼ã€‚

ä½¿ç”¨å±‚æ¬¡éå†æ¯”è¾ƒç®€å•

é€’å½’å®ç°ï¼šå‰ä¸­ååºéƒ½ä¸€æ ·ï¼Œå› ä¸ºæ ¹çš„éƒ¨åˆ†ä¸éœ€è¦è¿›è¡Œå¤„ç†

1. æ‰¾æ·±åº¦æœ€å¤§çš„å¶å­ç»“ç‚¹
2. ä¼˜å…ˆéå†å·¦ä¾§ç»“ç‚¹å³å¯æ‰¾åˆ°æœ€å·¦è¾¹çš„å€¼

```Java
class Solution {
    private int maxDepth;
    private int result;
    public int findBottomLeftValue(TreeNode root) {
        maxDepth = -1;
        dfs(root, 0);
        return result;
    }

    private void dfs(TreeNode cur, int depth) {
        if (cur.left == null && cur.right == null) {
            if (depth > maxDepth) {
                maxDepth = depth;
                result = cur.val;
            }
            return;
        }

        if (cur.left != null) {
            dfs(cur.left, depth + 1);
        }
        if (cur.right != null) {
            dfs(cur.right, depth + 1);
        }
    }
}
```

# æ ‘çš„å±æ€§

## æ±‚æ ‘çš„é«˜åº¦/æ·±åº¦

* é«˜åº¦ï¼š**ååº**ï¼Œåœ¨å­ç»“ç‚¹çš„åŸºç¡€ä¸Š+1
* æ·±åº¦ï¼š**å‰åº**ï¼Œåœ¨çˆ¶ç»“ç‚¹çš„åŸºç¡€ä¸Š+1

### äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦

[leetcode.cn/problems/maximum-depth-of-binary-tree/description/](https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/)

> ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ `root`â€‹ ï¼Œè¿”å›å…¶æœ€å¤§æ·±åº¦ã€‚
>
> äºŒå‰æ ‘çš„ **æœ€å¤§æ·±åº¦** æ˜¯æŒ‡ä»æ ¹èŠ‚ç‚¹åˆ°æœ€è¿œå¶å­èŠ‚ç‚¹çš„æœ€é•¿è·¯å¾„ä¸Šçš„èŠ‚ç‚¹æ•°ã€‚

* ç©ºæ ‘ï¼š0
* ä»…æœ‰æ ¹ç»“ç‚¹ï¼š1
* æœ‰å­æ ‘ï¼š`max(maxDepth(left), maxDepth(right)) + 1`â€‹

> DFSï¼šååºéå†

```Java
class Solution {
    public int maxDepth(TreeNode root) {
        if (root == null) {
            return 0;
        }  
        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
		/*
		int leftDepth = maxDepth(root.left);		// å·¦
		int rightDepth = maxDepth(root.right);		// å³
		return Math.max(leftDepth, rightDepth) + 1;	// æ ¹
		*/
    }
}
```

> BFS

```Java
import java.util.Queue;
import java.util.LinkedList;

class Solution {
    public int maxDepth(TreeNode root) {
        if (root == null) {
            return 0;
        }
        int depth = 0;
        Queue<TreeNode> q = new LinkedList<>();
        q.add(root);
        int size;
        while (!q.isEmpty()) {
            size = q.size();
            depth++;
            while (size > 0) {
                size--;
                TreeNode cur = q.remove();
                if (cur.left != null) {
                    q.add(cur.left);
                }
                if (cur.right != null) {
                    q.add(cur.right);
                }
            }
        }
        return depth;
    }
}
```

### Nå‰æ ‘çš„æœ€å¤§æ·±åº¦

[leetcode.cn/problems/maximum-depth-of-n-ary-tree/description/](https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/description/)

> ç»™å®šä¸€ä¸ª N å‰æ ‘ï¼Œæ‰¾åˆ°å…¶æœ€å¤§æ·±åº¦ã€‚
>
> æœ€å¤§æ·±åº¦æ˜¯æŒ‡ä»æ ¹èŠ‚ç‚¹åˆ°æœ€è¿œå¶å­èŠ‚ç‚¹çš„æœ€é•¿è·¯å¾„ä¸Šçš„èŠ‚ç‚¹æ€»æ•°ã€‚

```Java
class Solution {
    public int maxDepth(Node root) {
        if (root == null) {
            return 0;
        }
        int result = 0;
        for (Node each : root.children) {
            result = Math.max(maxDepth(each), result);
        }
        return result + 1;
    }
}
```

### äºŒå‰æ ‘çš„æœ€å°æ·±åº¦

[leetcode.cn/problems/minimum-depth-of-binary-tree/description/](https://leetcode.cn/problems/minimum-depth-of-binary-tree/description/)

> ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œæ‰¾å‡ºå…¶æœ€å°æ·±åº¦ã€‚
>
> æœ€å°æ·±åº¦æ˜¯ä»æ ¹èŠ‚ç‚¹åˆ°æœ€è¿‘å¶å­èŠ‚ç‚¹çš„æœ€çŸ­è·¯å¾„ä¸Šçš„èŠ‚ç‚¹æ•°é‡ã€‚
>
> **è¯´æ˜ï¼š** å¶å­èŠ‚ç‚¹æ˜¯æŒ‡æ²¡æœ‰å­èŠ‚ç‚¹çš„èŠ‚ç‚¹ã€‚

ååºéå†ï¼Œä»ä¸‹å±‚æœé›†ä¿¡æ¯è¿”å›ä¸Šå±‚

|å·¦|å³|ç»“æœ|
| ------| ------| ------------------------------|
|ç©º|éç©º|1 + right|
|éç©º|ç©º|1 + left|
|ç©º|ç©º|1 + min(left, right) = 1 + 0|
|éç©º|éç©º|1 + min(left, right)|

```Java
class Solution {
    public int minDepth(TreeNode root) {
        return getHeight(root);
    }

    private int getHeight(TreeNode cur) {
        if (cur == null) {
            return 0;
        }

        int left = getHeight(cur.left);     // å·¦
        int right = getHeight(cur.right);   // å³
        // æ ¹
        if (cur.left == null && cur.right != null) {
            return 1 + right;
        } else if (cur.left != null && cur.right == null) {
            return 1 + left;
        } else {
            return 1 + Math.min(left, right);
        }
    }
}
```

> ç®€åŒ–ç‰ˆ

```Java
class Solution {
    public int minDepth(TreeNode root) {
        return getHeight(root);
    }

    private int getHeight(TreeNode cur) {
        if (cur == null) {
            return 0;
        }
        if (cur.left == null && cur.right != null) {
            return 1 + getHeight(cur.right);
        } else if (cur.left != null && cur.right == null) {
            return 1 + getHeight(cur.left);
        } else {
            return 1 + Math.min(getHeight(cur.left), getHeight(cur.right));
        }
    }
}
```

## æ±‚ç»“ç‚¹æ•°é‡

* ç©ºæ ‘ï¼š0
* éç©ºæ ‘ï¼š`countNode(left) + countNode(right) + 1`â€‹

### ä»»æ„äºŒå‰æ ‘çš„ç»“ç‚¹ä¸ªæ•°

ä»»æ„éå†å‡å¯

```Java
class Solution {
    public int countNodes(TreeNode root) {
        return getNodes(root);
    }

    private int getNodes(TreeNode cur) {
        if (cur == null) {
            return 0;
        }
        return getNodes(cur.left) + getNodes(cur.right) + 1;	// ååºéå†
    }
}
```

### å®Œå…¨äºŒå‰æ ‘çš„ç»“ç‚¹ä¸ªæ•°

[leetcode.cn/problems/count-complete-tree-nodes/description/](https://leetcode.cn/problems/count-complete-tree-nodes/description/)

> ç»™ä½ ä¸€æ£µ **å®Œå…¨äºŒå‰æ ‘** çš„æ ¹èŠ‚ç‚¹ `root`â€‹ ï¼Œæ±‚å‡ºè¯¥æ ‘çš„èŠ‚ç‚¹ä¸ªæ•°ã€‚
>
> [å®Œå…¨äºŒå‰æ ‘](https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/7773232?fr=aladdin) çš„å®šä¹‰å¦‚ä¸‹ï¼šåœ¨å®Œå…¨äºŒå‰æ ‘ä¸­ï¼Œé™¤äº†æœ€åº•å±‚èŠ‚ç‚¹å¯èƒ½æ²¡å¡«æ»¡å¤–ï¼Œå…¶ä½™æ¯å±‚èŠ‚ç‚¹æ•°éƒ½è¾¾åˆ°æœ€å¤§å€¼ï¼Œå¹¶ä¸”æœ€ä¸‹é¢ä¸€å±‚çš„èŠ‚ç‚¹éƒ½é›†ä¸­åœ¨è¯¥å±‚æœ€å·¦è¾¹çš„è‹¥å¹²ä½ç½®ã€‚è‹¥æœ€åº•å±‚ä¸ºç¬¬ `h`â€‹ å±‚ï¼Œåˆ™è¯¥å±‚åŒ…å« `1~2`â€‹<sup>â€‹`h`â€‹</sup>â€‹ ä¸ªèŠ‚ç‚¹ã€‚

å¯ä»¥ä½¿ç”¨æ™®é€šäºŒå‰æ ‘çš„è§£æ³•ï¼Œä¹Ÿå¯ä»¥ä»å®Œå…¨äºŒå‰æ ‘çš„å®šä¹‰å…¥æ‰‹

* åªæœ‰æœ€åº•å±‚å¯èƒ½æ²¡å¡«æ»¡
* åˆ¤æ–­å­æ ‘æ˜¯å¦ä¸ºå®Œç¾äºŒå‰æ ‘ï¼Œå¯ç”±å…¬å¼è®¡ç®—ç»“ç‚¹ä¸ªæ•°

  * å®Œç¾äºŒå‰æ ‘ï¼šåˆ¤æ–­å·¦å­æ ‘çš„å·¦ä¾§ç»“ç‚¹æ•°å’Œå³å­æ ‘çš„å³ä¾§ç»“ç‚¹æ•°æ˜¯å¦ç›¸åŒï¼ˆæ ¹æ®å®Œå…¨äºŒå‰æ ‘çš„æ€§è´¨ï¼‰
  * å¶å­ç»“ç‚¹æ˜¯å®Œç¾äºŒå‰æ ‘

```Java
class Solution {
    public int countNodes(TreeNode root) {
        return getNodes(root);
    }

    private int getNodes(TreeNode cur) {
        // ç»ˆæ­¢ä¸ä»…è¦åˆ¤æ–­æ˜¯å¦ä¸ºç©ºï¼Œè¿˜éœ€è¦åˆ¤æ–­æ˜¯å¦ä¸ºå®Œç¾äºŒå‰æ ‘
        if (cur == null) {
            return 0;
        }
        // åˆ¤æ–­æ˜¯å¦ä¸ºå®Œç¾äºŒå‰æ ‘
        TreeNode left = cur.left;
        TreeNode right = cur.right;
        int leftDepth = 0, rightDepth = 0;
        while (left != null) {
            left = left.left;
            leftDepth++;
        }
        while (right != null) {
            right = right.right;
            rightDepth++;
        }
		// å¦‚æœæ˜¯å®Œç¾äºŒå‰æ ‘ï¼Œç›´æ¥ç”¨å…¬å¼
        if (leftDepth == rightDepth) {
            return (2 << leftDepth) - 1;
        }

        return getNodes(cur.left) + getNodes(cur.right) + 1;
    }
}
```

## æ±‚å¶å­ç»“ç‚¹æ•°é‡

* ç©ºæ ‘ï¼š0
* ä»…æœ‰æ ¹ç»“ç‚¹ï¼š1
* æœ‰å­æ ‘ï¼š`getLeaves(left) + getLeaves(right)`â€‹

## å¤åˆ¶äºŒå‰æ ‘

1. å¤åˆ¶æ ¹
2. å¤åˆ¶left
3. å¤åˆ¶right

## åˆ¤æ–­ç›¸åŒçš„æ ‘

[leetcode.cn/problems/same-tree/description/](https://leetcode.cn/problems/same-tree/description/)

> ç»™ä½ ä¸¤æ£µäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ `p`â€‹ å’Œ `q`â€‹ ï¼Œç¼–å†™ä¸€ä¸ªå‡½æ•°æ¥æ£€éªŒè¿™ä¸¤æ£µæ ‘æ˜¯å¦ç›¸åŒã€‚
>
> å¦‚æœä¸¤ä¸ªæ ‘åœ¨ç»“æ„ä¸Šç›¸åŒï¼Œå¹¶ä¸”èŠ‚ç‚¹å…·æœ‰ç›¸åŒçš„å€¼ï¼Œåˆ™è®¤ä¸ºå®ƒä»¬æ˜¯ç›¸åŒçš„ã€‚

å’Œ**å¯¹ç§°äºŒå‰æ ‘**ä¸€æ ·ï¼Œå¯ä»¥ä½¿ç”¨åŒæŒ‡é’ˆçš„æ€è·¯

```Java
class Solution {
    public boolean isSameTree(TreeNode p, TreeNode q) {
        return compare(p, q);
    }

    private boolean compare(TreeNode p, TreeNode q) {
        if (p == null && q == null) {
            return true;
        } else if (p != null && q == null || p == null && q != null) {
            return false;
        } else {
            return p.val == q.val && compare(p.left, q.left) && compare(p.right, q.right);
        }
    }
}
```

# æ ‘çš„æ„é€ 

æ„é€ ç±»çš„é¢˜è¦ç”¨**å‰åº**éå†ï¼Œå…ˆå¤„ç†æ ¹ï¼Œå†å¤„ç†å­ç»“ç‚¹

## åŒäº²å­˜å‚¨æ³•

* ç¼–å·:ä»æ ¹ç»“ç‚¹ï¼ˆç¼–å·ä¸º0 )å¼€å§‹ï¼Œ  
  æŒ‰ä»ä¸Šåˆ°ä¸‹çš„å±‚æ¬¡é¡ºåºï¼Œ æ¯ä¸€å±‚æŒ‰ä»å·¦åˆ°å³çš„é¡ºåºï¼Œ é€’å¢åœ°ä¾æ¬¡ç»™æ¯ä¸€ä¸ªç»“ç‚¹ä¸€ä¸ªç¼–å·ã€‚
* å­˜å‚¨:ç”¨æ•°ç»„`tree[n]`â€‹æ¥è¡¨ç¤ºæ ‘çš„é¡ºåºå­˜å‚¨ï¼Œæ•°ç»„æ¯ä¸ªå…ƒç´ æ˜¯ä¸€ä¸ªç»“æ„ä½“ï¼Œ å®ƒåŒ…å«ä¸¤ä¸ªæˆå‘˜ data å’Œ parent; data å­˜å‚¨ä¸€ä¸ªç»“ç‚¹çš„å€¼ï¼Œparent å­˜å‚¨è¯¥ç»“ç‚¹çš„åŒäº²ç»“ç‚¹åœ¨è¯¥æ•°ç»„ä¸­çš„ä¸‹æ ‡ã€‚æ ¹ç»“ç‚¹`tree[root].parent=-1`â€‹

â€‹![image](assets/image-20241025110624-cf3i5wq.png)â€‹

åå‘è¿˜åŸ

1. å°†çˆ¶ç»“ç‚¹ä¸º *i* çš„ç»“ç‚¹å­˜åˆ°äºŒç»´æ•°ç»„ `prts[i][last]`â€‹ä¸­ï¼ˆä¸‹é¢ä»£ç ä¸­ä½¿ç”¨äº†å¯å˜é•¿æ•°ç»„çš„æ•°ç»„ï¼‰
2. è¿›è¡ŒBFSï¼Œå»ºç«‹ç»“ç‚¹å…³ç³»

```cpp
struct Node {
	int val_;
	vector<Node*> son_;
}

Tree::Tree() {
    size_ = 0;

    vector<int> prts[N];
    int v, prt;
    while (cin >> v >> prt) {
        if (prt == -1) {
            root_ = new Node{v};
        } else {
            prts[prt].push_back(v);
        }
        size_++;
    }

    queue<Node*> q;
    q.push(root_);
    while (!q.empty()) {
        Node* cur = q.front();
        q.pop();

        prt = cur->data_;
        for (int i = 0; i < prts[prt].size(); i++) {
            Node* newNode = new Node{prts[prt][i]};
            cur->son_.push_back(newNode);
            q.push(newNode);
        }
    }
}
```

## å­©å­å…„å¼Ÿè¡¨ç¤ºæ³•

â€‹![image](assets/image-20241105095956-iwag3wx.png)â€‹

## æ‹¬å·è¡¨ç¤º

ç»™å®šæ ‘çš„æ‹¬å·è¡¨ç¤ºï¼Œå¦‚ä½•å»ºç«‹ä¸€æ£µæŒ‰æ ‡å‡†å½¢å¼å­˜å‚¨çš„åº¦ä¸ºmçš„æ ‘ï¼Ÿ

$$
A(B(E,F,G),C,D(H,I(J)))
$$

```cpp
#include <iostream>
#include <stack>
using namespace std;
const int MAXN = 10;

typedef struct mTreeNode
{
    char data;
    struct mTreeNode **child;
} Node;

Node *initNode(char a, int m)
{
    Node *p = new Node{a};
    p->child = new Node *[m];
    return p;
}

Node *buildTree(char a[], int left, int right, int m)
{
    if (left > right)
        return nullptr;

    if (left == right) // single character
        return initNode(a[left], m);

    Node *root = initNode(a[left], m);
    // é€’å½’åˆ‡åˆ†

    int childNo = 0;
    int i = left + 2, j = right - 1; // å»é™¤æœ€å¤–å±‚æ‹¬å·
    stack<char> s;

    int k = i;
    char ch = a[i];
    while (k <= j)
    {
        switch (ch)
        {
        case '(':
            s.push(ch);
            break;
        case ')':
            s.pop();
            break;
        case ',':
            if (s.empty())
            {
                root->child[childNo++] = buildTree(a, i, k - 1, m);
                i = k + 1;
            }
            break;
        }
        ch = a[++k];
    }
    root->child[childNo] = buildTree(a, i, j, m); // last child
    return root;
}
```

## æ ‘çš„äºŒå‰é“¾è¡¨è¡¨ç¤º

> æŠŠä»»æ„æ¬¡æ ‘è½¬æ¢æˆäºŒå‰æ ‘(å½¢æ€)

â€‹![image](assets/image-20241122091822-39qklkh.png)â€‹

â€‹![image](assets/image-20241122091826-ky4rsfx.png)â€‹

> è¿˜åŸ

æ³¨æ„æ¯ä¸€å±‚çš„ç»“ç‚¹é¡ºåºæ˜¯åçš„

```cpp
TreeNode* convert(BiTreeNode* cur, TreeNode* pre) {
    if (cur == nullptr) {
        return nullptr;
    }

    TreeNode* tn = new TreeNode;
    tn->data = cur->data;

    if (cur->right != nullptr) {
        TreeNode* b = convert(cur->right, pre);
        pre->son.push_back(b);
    }
    if (cur->left != nullptr) {
        TreeNode* c = convert(cur->left, tn);
        tn->son.push_back(c);
    }

    return tn;
}
```

## æ ¹æ®éå†ç»“æœæ„é€ äºŒå‰æ ‘

### ä¸­åºååºæ„é€ äºŒå‰æ ‘

[leetcode.cn/problems/construct-binary-tree-from-inorder-and-post...](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

> ç»™å®šä¸¤ä¸ªæ•´æ•°æ•°ç»„ `inorder`â€‹ å’Œ `postorder`â€‹ ï¼Œå…¶ä¸­ `inorder`â€‹ æ˜¯äºŒå‰æ ‘çš„ä¸­åºéå†ï¼Œ `postorder`â€‹ æ˜¯åŒä¸€æ£µæ ‘çš„ååºéå†ï¼Œè¯·ä½ æ„é€ å¹¶è¿”å›è¿™é¢— *äºŒå‰æ ‘* ã€‚

1. ååºæ•°ç»„ä¸º0 -> null
2. åç»­æ•°ç»„æœ€åä¸€ä¸ªå…ƒç´ ä¸º**æ ¹ç»“ç‚¹**
3. å¯»æ‰¾**æ ¹ç»“ç‚¹**åœ¨**ä¸­åº**æ•°ç»„ä¸­çš„ä½ç½®åšåˆ‡å‰²

    1. å·¦åŒºé—´ä¸ºå·¦å­æ ‘
    2. å³åŒºé—´ä¸ºå³å­æ ‘
4. æ ¹æ®åˆ‡å‰²çš„å·¦ã€å³åŒºé—´ï¼Œåœ¨**ååº**æ•°ç»„ä¸­å¯»æ‰¾ï¼ˆæ‰¾å¯¹åº”ä¸ªæ•°ï¼‰
5. é€’å½’å¤„ç†å·¦åŒºé—´ã€å³åŒºé—´ï¼ˆåˆ†æ²»ï¼‰

é»˜è®¤æ— é‡å¤å…ƒç´ ï¼Œä¸ç„¶æ— æ³•æ­£ç¡®åˆ‡å‰²

```Java
class Solution {
    public TreeNode buildTree(int[] inorder, int[] postorder) {
        return buildHelper(inorder, 0, inorder.length - 1, postorder, 0, postorder.length - 1);
    }

    private TreeNode buildHelper(int[] inorder, int il, int ir, int[] postorder, int pl, int pr) {
        if (il > ir) {
            return null;
        }
        TreeNode root = new TreeNode(postorder[pr]);
        int cur = 0;
        while (il + cur <= ir && inorder[il + cur] != postorder[pr]) {
            cur++;
        }
        root.left = buildHelper(inorder, il, il + cur - 1, postorder, pl, pl + cur - 1);
        root.right = buildHelper(inorder, il + cur + 1, ir, postorder, pl + cur, pr - 1);
        return root;
    }
}
```

å‰åºå’Œä¸­åºä¹Ÿæ˜¯ä¸€æ ·çš„æ€è·¯

> **ä¼˜åŒ–**ï¼šä½¿ç”¨å“ˆå¸Œè¡¨æå‰æ˜ å°„ä¸‹æ ‡ï¼Œå‡å°‘æŸ¥è¯¢çš„æ¶ˆè€—

```Java
class Solution {
    private HashMap<Integer, Integer> inorderMap;
    public TreeNode buildTree(int[] inorder, int[] postorder) {
        inorderMap = new HashMap<>();
        for (int i = 0; i < inorder.length; i++) {
            inorderMap.put(inorder[i], i);
        }
        return buildHelper(inorder, 0, inorder.length - 1, postorder, 0, postorder.length - 1);
    }

    private TreeNode buildHelper(int[] inorder, int il, int ir, int[] postorder, int pl, int pr) {
        if (il > ir) {
            return null;
        }
        if (il == ir) {
            return new TreeNode(postorder[pr], null, null);
        }
        TreeNode root = new TreeNode(postorder[pr]);
        int dif = inorderMap.get(postorder[pr]) - il;
        root.left = buildHelper(inorder, il, il + dif - 1, postorder, pl, pl + dif - 1);
        root.right = buildHelper(inorder, il + dif + 1, ir, postorder, pl + dif, pr - 1);
        return root;
    }
}
```

### å‰åºååºæ„é€ äºŒå‰æ ‘

## æœ€å¤§äºŒå‰æ ‘

[leetcode.cn/problems/maximum-binary-tree/description/](https://leetcode.cn/problems/maximum-binary-tree/description/)

> ç»™å®šä¸€ä¸ªä¸é‡å¤çš„æ•´æ•°æ•°ç»„ `nums`â€‹ ã€‚ **æœ€å¤§äºŒå‰æ ‘** å¯ä»¥ç”¨ä¸‹é¢çš„ç®—æ³•ä» `nums`â€‹ é€’å½’åœ°æ„å»º:
>
> 1. åˆ›å»ºä¸€ä¸ªæ ¹èŠ‚ç‚¹ï¼Œå…¶å€¼ä¸º `nums`â€‹ ä¸­çš„æœ€å¤§å€¼ã€‚
> 2. é€’å½’åœ°åœ¨æœ€å¤§å€¼ **å·¦è¾¹** çš„ **å­æ•°ç»„å‰ç¼€ä¸Š** æ„å»ºå·¦å­æ ‘ã€‚
> 3. é€’å½’åœ°åœ¨æœ€å¤§å€¼ **å³è¾¹** çš„ **å­æ•°ç»„åç¼€ä¸Š** æ„å»ºå³å­æ ‘ã€‚
>
> è¿”å› *â€‹`nums`â€‹*â€‹ *æ„å»ºçš„*  ***æœ€å¤§äºŒå‰æ ‘***  ã€‚

```Java
class Solution {
    public TreeNode constructMaximumBinaryTree(int[] nums) {
        return BuildHelper(nums, 0, nums.length - 1);
    }

    private TreeNode BuildHelper(int[] nums, int ml, int mr) {
        if (ml > mr) {
            return null;
        }
        int maxValue = 0;
        int maxIndex = ml;
        for (int i = ml; i <= mr; i++) {
            if (maxValue < nums[i]) {
                maxValue = nums[i];
                maxIndex = i;
            }
        }
        return new TreeNode(maxValue, BuildHelper(nums, ml, maxIndex - 1), BuildHelper(nums, maxIndex + 1, mr));
    }
}
```

# æ ‘çš„ä¿®æ”¹

## ç¿»è½¬äºŒå‰æ ‘

[leetcode.cn/problems/invert-binary-tree/description/](https://leetcode.cn/problems/invert-binary-tree/description/)

ç»™ä½ ä¸€æ£µäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ `root`â€‹ ï¼Œç¿»è½¬è¿™æ£µäºŒå‰æ ‘ï¼Œå¹¶è¿”å›å…¶æ ¹èŠ‚ç‚¹ã€‚

â€‹![image](assets/image-20241114220931-sduipjh.png)â€‹

### DFS

```Java
class Solution {
    public TreeNode invertTree(TreeNode root) {
        invert(root);
        return root;
    }

    private void invert(TreeNode cur) {
        if (cur == null) {
            return;
        }
		// å‰åºå½¢å¼ï¼Œæ”¹ä¸ºååºä¹Ÿå¯ï¼›ä¸­åºéœ€è¦ä¸¤æ¬¡å¯¹å·¦å­æ ‘å¤„ç†
        TreeNode temp = cur.left;
        cur.left = cur.right;
        cur.right = temp;

        invert(cur.left);
        invert(cur.right);
    }
}
```

### BFS

```Java
import java.util.*;
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if (root == null) {
            return null;
        }
        Queue<TreeNode> q = new LinkedList<>();
        q.add(root);
        int size;
        while (!q.isEmpty()) {
            size = q.size();
            while (size > 0) {
                size--;
                TreeNode cur = q.remove();
                swapNode(cur);
                if (cur.left != null) {
                    q.add(cur.left);
                }
                if (cur.right != null) {
                    q.add(cur.right);
                }
            }
        }
        return root;
    }
    private void swapNode(TreeNode cur) {
        TreeNode temp = cur.left;
        cur.left = cur.right;
        cur.right = temp;
    }
}
```

## åˆå¹¶äºŒå‰æ ‘

[leetcode.cn/problems/merge-two-binary-trees/](https://leetcode.cn/problems/merge-two-binary-trees/)

> ç»™ä½ ä¸¤æ£µäºŒå‰æ ‘ï¼š `root1`â€‹ å’Œ `root2`â€‹ ã€‚
>
> æƒ³è±¡ä¸€ä¸‹ï¼Œå½“ä½ å°†å…¶ä¸­ä¸€æ£µè¦†ç›–åˆ°å¦ä¸€æ£µä¹‹ä¸Šæ—¶ï¼Œä¸¤æ£µæ ‘ä¸Šçš„ä¸€äº›èŠ‚ç‚¹å°†ä¼šé‡å ï¼ˆè€Œå¦ä¸€äº›ä¸ä¼šï¼‰ã€‚ä½ éœ€è¦å°†è¿™ä¸¤æ£µæ ‘åˆå¹¶æˆä¸€æ£µæ–°äºŒå‰æ ‘ã€‚åˆå¹¶çš„è§„åˆ™æ˜¯ï¼šå¦‚æœä¸¤ä¸ªèŠ‚ç‚¹é‡å ï¼Œé‚£ä¹ˆå°†è¿™ä¸¤ä¸ªèŠ‚ç‚¹çš„å€¼ç›¸åŠ ä½œä¸ºåˆå¹¶åèŠ‚ç‚¹çš„æ–°å€¼ï¼›å¦åˆ™ï¼Œ**ä¸ä¸º** null çš„èŠ‚ç‚¹å°†ç›´æ¥ä½œä¸ºæ–°äºŒå‰æ ‘çš„èŠ‚ç‚¹ã€‚
>
> è¿”å›åˆå¹¶åçš„äºŒå‰æ ‘ã€‚
>
> **æ³¨æ„:**  åˆå¹¶è¿‡ç¨‹å¿…é¡»ä»ä¸¤ä¸ªæ ‘çš„æ ¹èŠ‚ç‚¹å¼€å§‹ã€‚

åŒæ­¥éå†ä¸¤ä¸ªäºŒå‰æ ‘ï¼ˆåŒæŒ‡é’ˆï¼‰

1. å…¨ä¸ºç©º

    1. è¿”å›null
2. å…¶ä¸­ä¸€ä¸ªä¸ºç©º

    1. ç›´æ¥è¿”å›å¦ä¸€ä¸ªéç©ºç»“ç‚¹
3. éƒ½ä¸ä¸ºç©º

    1. é€’å½’

```Java
class Solution {
    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {
        if (root1 == null) {	// å·²ç»åŒ…å«äº†root1å’Œroot2åŒæ—¶ä¸ºç©ºçš„æƒ…å†µ
            return root2;
        } else if (root2 == null) {
            return root1;
        }
        return new TreeNode(root1.val + root2.val, mergeTrees(root1.left, root2.left), mergeTrees(root1.right, root2.right));
    }
}
```

# åˆ¤æ–­ç‰¹æ®Šæ ‘

## æ»¡äºŒå‰æ ‘

åˆ¤æ–­æ˜¯å¦æœ‰åº¦ä¸º1çš„ç»“ç‚¹

```cpp
bool BinaryTree::Is_Full_Tree(BiNODE* node) {
    if (node == nullptr) {
        return false;
    }
    queue<BiNODE*> q;
    q.push(node);
    while (!q.empty()) {
        BiNODE* cur = q.front();
        q.pop();
        if (cur == nullptr) {
            continue;
        }
        if (cur->lchild == nullptr && cur->rchild != nullptr || cur->rchild == nullptr && cur->lchild != nullptr) {
            return false;
        }
        q.push(cur->lchild);
        q.push(cur->rchild);
    }
    return true;
}
```

## å®Œå…¨äºŒå‰æ ‘

1. æœ‰å³å­ç»“ç‚¹ä½†æ— å·¦å­ç»“ç‚¹ä¸€å®šä¸æ˜¯å®Œå…¨äºŒå‰æ ‘
2. å½“éå†åˆ°åªæœ‰å·¦å­ç»“ç‚¹ï¼Œæˆ–ä¸¤ä¸ªå­ç»“ç‚¹éƒ½ä¸å­˜åœ¨çš„ç»“ç‚¹ï¼Œåœ¨è¿™ä¸ªç»“ç‚¹ä¹‹åä¸åº”è¯¥å†å‡ºç°æœ‰å­ç»“ç‚¹çš„ç»“ç‚¹

```cpp
bool BinaryTree::Is_Complete_Tree(BiNODE* node) {
    if (node == nullptr) {
        return false;
    }
    queue<BiNODE*> q;
    q.push(node);
    bool noChild = false;
    while (!q.empty()) {
        BiNODE* cur = q.front();
        q.pop();
        if (cur == nullptr) {
            continue;
        }
        if (cur->lchild == nullptr && cur->rchild != nullptr) {
            return false;
        }

        if (noChild && cur->lchild != nullptr) {
            return false;
        }
        if (cur->lchild == nullptr || cur->rchild == nullptr) {
            noChild = true;
        }

        q.push(cur->lchild);
        q.push(cur->rchild);
    }
    return true;
}
```

## å®Œç¾äºŒå‰æ ‘

æ ¹æ®æ ‘é«˜å’Œç»“ç‚¹æ•°åˆ¤æ–­ï¼šæ·±åº¦ï¼ˆé«˜åº¦ï¼‰ä¸º *d* (â‰¥1)çš„äºŒå‰æ ‘æ˜¯å®Œç¾äºŒå‰æ ‘çš„**å……åˆ†å¿…è¦æ¡ä»¶**æ˜¯  
æ ‘ä¸­æœ‰ 2*<sup>d</sup>*âˆ’1 ä¸ªç»“ç‚¹ã€‚

```cpp
bool BinaryTree::Is_Perfect_Tree(BiNODE* node) {
    if (node == nullptr) {
        return false;
    }
    int size = Size_Of_Tree(GetRoot());
    int height = Height_Of_Tree(GetRoot());
	// ä»¥ä¸‹ä»£ç ç­‰åŒäº int sum = pow(2, height) - 1
    int a = 1;
    int sum = 0;
    for (int i = 0; i < height; i++) {
        sum += a;
        a *= 2;
    }

    return size == sum;
}
```

## å¹³è¡¡äºŒå‰æ ‘

[leetcode.cn/problems/balanced-binary-tree/description/](https://leetcode.cn/problems/balanced-binary-tree/description/)

**å¹³è¡¡äºŒå‰æ ‘** æ˜¯æŒ‡è¯¥æ ‘æ‰€æœ‰ç»“ç‚¹çš„å·¦å³å­æ ‘çš„é«˜åº¦ç›¸å·®ä¸è¶…è¿‡ 1ã€‚

```Java
class Solution {
    public boolean isBalanced(TreeNode root) {
        return getHeight(root) != -1;
    }

    private int getHeight(TreeNode root) {
        if (root == null) {
            return 0;
        }

        int left = getHeight(root.left);	// å·¦
        if (left == -1) {
            return -1;
        }
        int right = getHeight(root.right);	// å³
        if (right == -1) {
            return -1;
        }
  
        if (Math.abs(left - right) > 1) {
            return -1;
        }
        return Math.max(left, right) + 1;	// æ ¹
    }
}
```

## å¯¹ç§°äºŒå‰æ ‘

[leetcode.cn/problems/symmetric-tree/description/](https://leetcode.cn/problems/symmetric-tree/description/)

> ç»™ä½ ä¸€ä¸ªäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ `root`â€‹ ï¼Œ æ£€æŸ¥å®ƒæ˜¯å¦è½´å¯¹ç§°ã€‚

1. å¯ä»¥è½¬æ¢æˆ**äºŒå‰æ ‘ç¿»è½¬ä¹‹åæ˜¯å¦å’ŒåŸæ¥çš„äºŒå‰æ ‘ç›¸åŒ**
2. ä»éå†è§’åº¦ï¼šç›¸å½“äºåŒæ—¶éå†å·¦å³ä¸¤ä¸ªå­æ ‘ï¼ˆåŒæŒ‡é’ˆçš„æ„Ÿè§‰ï¼‰

    1. å·¦æ ‘çš„leftç»“ç‚¹è¦ä¸å³æ ‘çš„rightç»“ç‚¹ç›¸åŒ
    2. å·¦æ ‘çš„rightç»“ç‚¹è¦ä¸å³æ ‘çš„leftç»“ç‚¹ç›¸åŒ

|å·¦|å³|Result|
| ----------------| ----------------| --------|
|ç©º|ç©º|true|
|ç©º|éç©º|false|
|éç©º|ç©º|false|
|éç©ºï¼ˆå€¼ä¸åŒï¼‰|éç©ºï¼ˆå€¼ä¸åŒï¼‰|false|
|éç©ºï¼ˆå€¼ç›¸åŒï¼‰|éç©ºï¼ˆå€¼ç›¸åŒï¼‰|true|

```Java
class Solution {
    public boolean isSymmetric(TreeNode root) {
        return compare(root.left, root.right);
    }

    private boolean compare(TreeNode left, TreeNode right) {
        if (left == null && right == null) {
            return true;
        } else if (left == null && right != null || left != null && right == null) {
            return false;
        } else {
            return left.val == right.val && compare(left.left, right.right) && compare(left.right, right.left);
        }
    }
}
```

å®è´¨ä¸Šåº”è¯¥æ˜¯**ååºéå†**

* å·¦æ ‘ï¼šå·¦å³ä¸­
* å³æ ‘ï¼šå³å·¦ä¸­

# äºŒå‰æ ‘å…¬å…±ç¥–å…ˆ

## äºŒå‰æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ

[leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/des...](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/description/)

> ç»™å®šä¸€ä¸ªäºŒå‰æ ‘, æ‰¾åˆ°è¯¥æ ‘ä¸­ä¸¤ä¸ªæŒ‡å®šèŠ‚ç‚¹çš„æœ€è¿‘å…¬å…±ç¥–å…ˆã€‚
>
> [ç™¾åº¦ç™¾ç§‘](https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin)ä¸­æœ€è¿‘å…¬å…±ç¥–å…ˆçš„å®šä¹‰ä¸ºï¼šâ€œå¯¹äºæœ‰æ ¹æ ‘ T çš„ä¸¤ä¸ªèŠ‚ç‚¹ pã€qï¼Œæœ€è¿‘å…¬å…±ç¥–å…ˆè¡¨ç¤ºä¸ºä¸€ä¸ªèŠ‚ç‚¹ xï¼Œæ»¡è¶³ x æ˜¯ pã€q çš„ç¥–å…ˆä¸” x çš„æ·±åº¦å°½å¯èƒ½å¤§ï¼ˆ**ä¸€ä¸ªèŠ‚ç‚¹ä¹Ÿå¯ä»¥æ˜¯å®ƒè‡ªå·±çš„ç¥–å…ˆ**ï¼‰ã€‚â€

äºŒå‰æ ‘åªèƒ½ä»ä¸Šå‘ä¸‹éå†ï¼Œä¸èƒ½ä»pã€qå¼€å§‹å‘ä¸Šï¼Œä½†æ˜¯**ååºéå†**å¯ä»¥å®ç°å°†ä¸‹å±‚çš„ç»“æœå‘ä¸Šå±‚ä¼ é€’

* å¦‚æœpä¸ä¸ºqçš„ç¥–å…ˆç»“ç‚¹ï¼ˆæˆ–ç›¸åï¼‰

  * ç»ˆæ­¢æ¡ä»¶ï¼šä¸ºç©ºï¼Œæˆ–åˆ¤æ–­å½“å‰ç»“ç‚¹æ˜¯å¦ä¸ºpæˆ–q
  * å› ä¸ºè¦æ‰¾æœ€è¿‘å…¬å…±ç¥–å…ˆï¼Œæ‰€ä»¥på’Œqä¸€å®šåˆ†åˆ«ä½äºè¿™ä¸ªç»“ç‚¹çš„å·¦å³å­æ ‘å½“ä¸­
* å¦‚æœpä¸ºqçš„ç¥–å…ˆç»“ç‚¹ï¼ˆæˆ–ç›¸åï¼‰

  * å®é™…ä¸Šè¿™ç§æƒ…å†µçš„å¤„ç†å’Œä¹‹å‰çš„å¤„ç†æ˜¯é‡åˆçš„
  * å› ä¸ºpä¸ºqçš„ç¥–å…ˆç»“ç‚¹æ—¶ï¼Œå½“é‡åˆ°pæ—¶ç›´æ¥è¿”å›pï¼Œqä¸€å®šåœ¨pä¸‹é¢ï¼Œä¸éœ€è¦å†å»éå†å¯»æ‰¾qäº†ï¼Œå¦åˆ™å°±æ˜¯ç¬¬ä¸€ç§æƒ…å†µ

```Java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        return postorder(root, p, q);
    }

    private TreeNode postorder(TreeNode cur, TreeNode p, TreeNode q) {
        if (cur == null || cur == p || cur == q) {
            return cur;
        }
        TreeNode left = postorder(cur.left, p, q);
        TreeNode right = postorder(cur.right, p, q);
        if (left != null && right != null) {
            // å·¦å³å­æ ‘éƒ½ä¸ä¸ºç©ºï¼Œåˆ™è¯´æ˜å½“å‰ç»“ç‚¹ä¸ºæœ€è¿‘å…¬å…±ç¥–å…ˆ
            return cur;
        } else if (left != null && right == null) {
            // å·¦å­æ ‘ä¸­å‡ºç°ç›®æ ‡å€¼ï¼Œå³å­æ ‘ä¸­æ²¡æœ‰ç›®æ ‡å€¼
            return left;
        } else if (left == null && right != null) {
            // å·¦å­æ ‘ä¸­æ²¡æœ‰ç›®æ ‡å€¼ï¼Œå³å­æ ‘ä¸­å‡ºç°ç›®æ ‡å€¼
            return right;
        } else {
            // ä¸¤ä¾§å­æ ‘éƒ½æ²¡æœ‰ç›®æ ‡å€¼
            return null;
        }
    }
}
```

# äºŒå‰æœç´¢æ ‘

## æ¦‚å¿µ

äºŒå‰æœç´¢æ ‘æ˜¯ä¸€ä¸ªæœ‰åºæ ‘

* è‹¥å®ƒçš„å·¦å­æ ‘ä¸ç©ºï¼Œåˆ™å·¦å­æ ‘ä¸Šæ‰€æœ‰ç»“ç‚¹çš„å€¼å‡**å°äº**å®ƒçš„æ ¹ç»“ç‚¹çš„å€¼ï¼›
* è‹¥å®ƒçš„å³å­æ ‘ä¸ç©ºï¼Œåˆ™å³å­æ ‘ä¸Šæ‰€æœ‰ç»“ç‚¹çš„å€¼å‡**å¤§äº**å®ƒçš„æ ¹ç»“ç‚¹çš„å€¼ï¼›
* å®ƒçš„å·¦ã€å³å­æ ‘ä¹Ÿåˆ†åˆ«ä¸ºäºŒå‰æ’åºæ ‘

â€‹![image](assets/image-20241108100640-orzt14g.png)â€‹

### å¹³è¡¡äºŒå‰æœç´¢æ ‘

å¹³è¡¡äºŒå‰æœç´¢æ ‘ï¼šåˆè¢«ç§°ä¸ºAVLï¼ˆAdelson-Velsky and Landisï¼‰æ ‘ï¼Œä¸”å…·æœ‰ä»¥ä¸‹æ€§è´¨ï¼šå®ƒæ˜¯ä¸€æ£µç©ºæ ‘æˆ–å®ƒçš„å·¦å³ä¸¤ä¸ªå­æ ‘çš„é«˜åº¦å·®çš„ç»å¯¹å€¼ä¸è¶…è¿‡1ï¼Œå¹¶ä¸”å·¦å³ä¸¤ä¸ªå­æ ‘éƒ½æ˜¯ä¸€æ£µå¹³è¡¡äºŒå‰æ ‘ã€‚

â€‹![image](assets/image-20241108100715-2chiu73.png)â€‹

## äºŒå‰æœç´¢æ ‘æœç´¢

> ç»™å®šäºŒå‰æœç´¢æ ‘ï¼ˆBSTï¼‰çš„æ ¹èŠ‚ç‚¹ `root`â€‹ å’Œä¸€ä¸ªæ•´æ•°å€¼ `val`â€‹ã€‚
>
> ä½ éœ€è¦åœ¨ BST ä¸­æ‰¾åˆ°èŠ‚ç‚¹å€¼ç­‰äº `val`â€‹ çš„èŠ‚ç‚¹ã€‚ è¿”å›ä»¥è¯¥èŠ‚ç‚¹ä¸ºæ ¹çš„å­æ ‘ã€‚ å¦‚æœèŠ‚ç‚¹ä¸å­˜åœ¨ï¼Œåˆ™è¿”å› `null`â€‹ ã€‚

### é€’å½’æ³•

1. å½“å‰å€¼ç­‰äºç›®æ ‡å€¼ï¼šè¿”å›ç»“æœ
2. å½“å‰å€¼å°äºç›®æ ‡å€¼ï¼šé€’å½’å³å­æ ‘
3. å½“å‰å€¼å¤§äºç›®æ ‡å€¼ï¼šé€’å½’å·¦å­æ ‘

```Java
class Solution {
    public TreeNode searchBST(TreeNode root, int val) {
        if (root == null) {
            return null;
        }
        if (root.val == val) {
            return root;
        } else if (root.val < val) {
            return searchBST(root.right, val);
        } else {
            return searchBST(root.left, val);
        }
    }
}
```

### è¿­ä»£æ³•

```Java
class Solution {
    public TreeNode searchBST(TreeNode root, int val) {
        TreeNode cur = root;
        while (cur != null) {
            if (cur.val == val) {
                break;
            } else if (cur.val < val) {
                cur = cur.right;
            } else {
                cur = cur.left;
            }
        }
        return cur;
    }
}
```

## åŒæŒ‡é’ˆ

### éªŒè¯äºŒå‰æœç´¢æ ‘

[leetcode.cn/problems/validate-binary-search-tree/description/](https://leetcode.cn/problems/validate-binary-search-tree/description/)

> ç»™ä½ ä¸€ä¸ªäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ `root`â€‹ ï¼Œåˆ¤æ–­å…¶æ˜¯å¦æ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„äºŒå‰æœç´¢æ ‘ã€‚
>
> **æœ‰æ•ˆ** äºŒå‰æœç´¢æ ‘å®šä¹‰å¦‚ä¸‹ï¼š
>
> * èŠ‚ç‚¹çš„å·¦å­æ ‘
>
>   åªåŒ…å«  **å°äº**  å½“å‰èŠ‚ç‚¹çš„æ•°ã€‚
> * èŠ‚ç‚¹çš„å³å­æ ‘åªåŒ…å« **å¤§äº** å½“å‰èŠ‚ç‚¹çš„æ•°ã€‚
> * æ‰€æœ‰å·¦å­æ ‘å’Œå³å­æ ‘è‡ªèº«å¿…é¡»ä¹Ÿæ˜¯äºŒå‰æœç´¢æ ‘ã€‚

ç©ºç»“ç‚¹ä¹Ÿä¸ºäºŒå‰æœç´¢æ ‘

è‹¥ä¸ºäºŒå‰æœç´¢æ ‘ï¼Œåˆ™ä½¿ç”¨ä¸­åºéå†å¾—åˆ°çš„æ•°ç»„æ˜¯æœ‰åºçš„

#### è½¬åŒ–ä¸ºæ•°ç»„

å°†ä¸­åºéå†å¾—åˆ°çš„ç»“æœè½¬ä¸ºæ•°ç»„è¿›è¡Œæœ‰åºåˆ¤æ–­

```Java
import java.util.ArrayList;
class Solution {
    private ArrayList<Integer> vec;
    public boolean isValidBST(TreeNode root) {
        vec = new ArrayList<>();
        inorder(root);
        for (int i = 1; i < vec.size(); i++) {
            if (vec.get(i - 1) >= vec.get(i)) {
                return false;
            }
        }
        return true;
    }

    private void inorder(TreeNode root) {
        if (root == null) {
            return;
        }
        inorder(root.left);
        vec.add(root.val);
        inorder(root.right);
    }
}
```

#### åœ¨éå†æ—¶è¿›è¡Œåˆ¤æ–­

è¦æ³¨æ„ï¼šæ ¹ç»“ç‚¹çš„å€¼è¦æ¯”å·¦å­æ ‘çš„**æ‰€æœ‰ç»“ç‚¹**çš„å€¼å¤§ï¼Œæ¯”å³å­æ ‘**æ‰€æœ‰èŠ‚ç‚¹**çš„å€¼å°

ç»´æŠ¤ä¸€ä¸ª`maxVal`â€‹ï¼Œå³å·²ç»éå†è¿‡çš„ç»“ç‚¹ä¸­æœ€å¤§çš„å€¼ï¼Œå› ä¸ºæŒ‰ç…§ä¸­åºéå†ï¼Œå¦‚æœæ˜¯äºŒå‰æœç´¢æ ‘ï¼Œé‚£ä¹ˆä¸€å®šæ˜¯å‡åºçš„ï¼Œ`maxVal`â€‹å•è°ƒé€’å¢  
è¿™æ ·å½“å‡ºç°ä¸€ä¸ªå°äºç­‰äº`maxVal`â€‹çš„å€¼æ—¶ï¼Œå°±è¯´æ˜ä¸æ˜¯äºŒå‰æœç´¢æ ‘äº†

```Java
class Solution {
    private long maxVal;
    public boolean isValidBST(TreeNode root) {
        maxVal = Long.MIN_VALUE;    // å·²ç»éå†è¿‡çš„ç»“ç‚¹ä¸­æœ€å¤§çš„å€¼
        return inorder(root);
    }

    private boolean inorder(TreeNode cur) {
        if (cur == null) {
            return true;
        }
        boolean left = inorder(cur.left);
        if (maxVal < cur.val) {
            maxVal = cur.val;
        } else {
            return false;
        }
        boolean right = inorder(cur.right);
        return left && right;
    }
}
```

#### åŒæŒ‡é’ˆä¼˜åŒ–

ä¸Šé¢çš„æ–¹æ³•å­˜åœ¨ä¸€ä¸ªé—®é¢˜ï¼šç°åœ¨çš„æ•°æ®èŒƒå›´é™åˆ¶åœ¨äº†[Integer.MIN_VALUE, Integer.MAX_VALUE]ä¸Šï¼Œå¯ä»¥ä½¿ç”¨Long.MIN_VALUEæ¥ä½œä¸º`maxVal`â€‹çš„åˆå§‹å€¼ï¼Œä½†æ˜¯å¦‚æœæ•°æ®èŒƒå›´æ‰©å±•åˆ°Longçš„èŒƒå›´ï¼Œé‚£ä¹ˆå°±èƒ½ç”¨è¿™ä¸ªæ–¹æ³•äº†ã€‚ä¼˜åŒ–æ–¹æ³•æ˜¯å½“å‰ç»“ç‚¹å’Œä¸Šä¸€ä¸ªç»“ç‚¹è¿›è¡Œæ¯”è¾ƒï¼Œå°±ä¸ç”¨å…³å¿ƒæ•°æ®èŒƒå›´äº†

```Java
class Solution {
    private TreeNode pre;   // è®°å½•å‰ä¸€ä¸ªéå†çš„ç»“ç‚¹
    public boolean isValidBST(TreeNode root) {
        pre = null;
        return inorder(root);
    }

    private boolean inorder(TreeNode cur) {
        if (cur == null) {
            return true;
        }

        boolean left = inorder(cur.left);
        if (pre != null && pre.val >= cur.val) {
            return false;
        }
        pre = cur;      // æ›´æ–°å‰ä¸€ä¸ªéå†çš„ç»“ç‚¹
        boolean right = inorder(cur.right);
        return left && right;
    }
}
```

### äºŒå‰æœç´¢æ ‘çš„æœ€å°ç»å¯¹å·®

[leetcode.cn/problems/minimum-absolute-difference-in-bst/descript...](https://leetcode.cn/problems/minimum-absolute-difference-in-bst/description/)

> ç»™ä½ ä¸€ä¸ªäºŒå‰æœç´¢æ ‘çš„æ ¹èŠ‚ç‚¹ `root`â€‹ ï¼Œè¿”å› **æ ‘ä¸­ä»»æ„ä¸¤ä¸åŒèŠ‚ç‚¹å€¼ä¹‹é—´çš„æœ€å°å·®å€¼** ã€‚
>
> å·®å€¼æ˜¯ä¸€ä¸ªæ­£æ•°ï¼Œå…¶æ•°å€¼ç­‰äºä¸¤å€¼ä¹‹å·®çš„ç»å¯¹å€¼ã€‚

* æš´åŠ›è§£æ³•ï¼šä½¿ç”¨ä¸­åºéå†è½¬å˜æˆæ•°ç»„ï¼Œå†è®¡ç®—ç›¸é‚»ç»“ç‚¹å·®å€¼

* åŒæŒ‡é’ˆæ³•ï¼šä¿ç•™ä¸Šä¸€æ¬¡éå†çš„ç»“ç‚¹ï¼Œç›´æ¥è®¡ç®—å·®å€¼å³å¯

```Java
class Solution {
    private TreeNode pre;
    private int result;
    public int minDiffInBST(TreeNode root) {
        pre = null;
        result = Integer.MAX_VALUE;
        inorder(root);
        return result;
    }

    private void inorder(TreeNode cur) {
        if (cur == null) {
            return;
        }
        inorder(cur.left);
        if (pre != null) {
            result = Math.min(result, cur.val - pre.val);
        }
        pre = cur;
        inorder(cur.right);
    }
}
```

### äºŒå‰æœç´¢æ ‘ä¸­çš„ä¼—æ•°

[leetcode.cn/problems/find-mode-in-binary-search-tree/description...](https://leetcode.cn/problems/find-mode-in-binary-search-tree/description/)

> ç»™ä½ ä¸€ä¸ªå«é‡å¤å€¼çš„äºŒå‰æœç´¢æ ‘ï¼ˆBSTï¼‰çš„æ ¹èŠ‚ç‚¹ `root`â€‹ ï¼Œæ‰¾å‡ºå¹¶è¿”å› BST ä¸­çš„æ‰€æœ‰ [ä¼—æ•°](https://baike.baidu.com/item/%E4%BC%97%E6%95%B0/44796)ï¼ˆå³ï¼Œå‡ºç°é¢‘ç‡æœ€é«˜çš„å…ƒç´ ï¼‰ã€‚
>
> å¦‚æœæ ‘ä¸­æœ‰ä¸æ­¢ä¸€ä¸ªä¼—æ•°ï¼Œå¯ä»¥æŒ‰ **ä»»æ„é¡ºåº** è¿”å›ã€‚
>
> å‡å®š BST æ»¡è¶³å¦‚ä¸‹å®šä¹‰ï¼š
>
> * ç»“ç‚¹å·¦å­æ ‘ä¸­æ‰€å«èŠ‚ç‚¹çš„å€¼ **å°äºç­‰äº** å½“å‰èŠ‚ç‚¹çš„å€¼
> * ç»“ç‚¹å³å­æ ‘ä¸­æ‰€å«èŠ‚ç‚¹çš„å€¼ **å¤§äºç­‰äº** å½“å‰èŠ‚ç‚¹çš„å€¼
> * å·¦å­æ ‘å’Œå³å­æ ‘éƒ½æ˜¯äºŒå‰æœç´¢æ ‘

* å¦‚æœæ²¡æœ‰ç©ºé—´å¤æ‚åº¦è¦æ±‚ï¼Œå¯ä»¥ä½¿ç”¨Mapå­˜å‚¨

  * ä½¿ç”¨åŒæŒ‡é’ˆä¼˜åŒ–Mapå­˜å‚¨
* æ±‚é¢‘ç‡ï¼Œå’Œæ ¹æ®é¢‘ç‡æ‰¾æ•°å€¼ï¼šéœ€è¦ä¸¤æ¬¡éå†

  * ä½¿ç”¨`clear()`â€‹å¯ä»¥ä¼˜åŒ–ä¸ºä¸€æ¬¡éå†
  * å› ä¸ºå½“å‡ºç°æ›´å¤§çš„`maxFreq`â€‹æ—¶ï¼Œä¹‹å‰å­˜å‚¨çš„ç»“æœä¸€å®šä¸æ»¡è¶³äº†ï¼Œç›´æ¥æ¸…ç©ºå³å¯

```Java
import java.util.ArrayList;

class Solution {
    private ArrayList<Integer> results;
    private TreeNode pre;
    private int maxFreq;
    private int curFreq;

    public int[] findMode(TreeNode root) {
        results = new ArrayList<>();
        pre = null;
        maxFreq = curFreq = 1;

        inorder(root);
        int[] result = new int[results.size()];

        for (int i = 0; i < result.length; i++) {
            result[i] = results.get(i);
        }
        return result;
    }

    private void inorder(TreeNode cur) {
        if (cur == null) {
            return;
        }
		// å·¦
        inorder(cur.left);
		// ä¸­
        if (pre != null) {
            if (pre.val == cur.val) {
                curFreq++;
            } else {
                curFreq = 1;
            }
        }
        pre = cur;		// æ›´æ–°åŒæŒ‡é’ˆ
		// æ›´æ–°ç»“æœé›†
        if (curFreq == maxFreq) {
            results.add(cur.val);
        } else if (curFreq > maxFreq) {
            results.clear();
            results.add(cur.val);
            maxFreq = curFreq;
        }
      	// å³
        inorder(cur.right);
    }
}
```

### äºŒå‰æœç´¢æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ

[leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-t...](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/description/)

> ç»™å®šä¸€ä¸ªäºŒå‰æœç´¢æ ‘, æ‰¾åˆ°è¯¥æ ‘ä¸­ä¸¤ä¸ªæŒ‡å®šèŠ‚ç‚¹çš„æœ€è¿‘å…¬å…±ç¥–å…ˆã€‚
>
> [ç™¾åº¦ç™¾ç§‘](https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin)ä¸­æœ€è¿‘å…¬å…±ç¥–å…ˆçš„å®šä¹‰ä¸ºï¼šâ€œå¯¹äºæœ‰æ ¹æ ‘ T çš„ä¸¤ä¸ªç»“ç‚¹ pã€qï¼Œæœ€è¿‘å…¬å…±ç¥–å…ˆè¡¨ç¤ºä¸ºä¸€ä¸ªç»“ç‚¹ xï¼Œæ»¡è¶³ x æ˜¯ pã€q çš„ç¥–å…ˆä¸” x çš„æ·±åº¦å°½å¯èƒ½å¤§ï¼ˆ**ä¸€ä¸ªèŠ‚ç‚¹ä¹Ÿå¯ä»¥æ˜¯å®ƒè‡ªå·±çš„ç¥–å…ˆ**ï¼‰ã€‚

å¯ä»¥ä½¿ç”¨äºŒå‰æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆçš„å†™æ³•

åˆ©ç”¨äºŒå‰æœç´¢æ ‘çš„ç‰¹æ€§ï¼š

* å¦‚æœ`cur.val > p.val && cur.val > q.val`â€‹ï¼špå’Œqä¸€å®šåœ¨`cur`â€‹çš„å·¦å­æ ‘ä¸Š
* å¦‚æœ`cur.val < p.val && cur.val < q.val`â€‹ï¼špå’Œqä¸€å®šåœ¨`cur`â€‹çš„å³å­æ ‘ä¸Š
* å¦‚æœ`cur.val < p.val && cur.val > q.val || cur.val > p.val && cur.val < q.val`â€‹ï¼šcurä¸ºpã€qçš„ç¥–å…ˆ

#### é€’å½’æ³•

```Java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        return findAncestor(root, p, q);
    }

    private TreeNode findAncestor(TreeNode cur, TreeNode p, TreeNode q) {
        if (cur == null || cur == p || cur == q) {
            return cur;
        }

        if (cur.val > p.val && cur.val > q.val) {
            return findAncestor(cur.left, p, q);
        } else if (cur.val < p.val && cur.val < q.val) {
            return findAncestor(cur.right, p, q);
        } else {
            return cur;
        }
    }
}
```

#### è¿­ä»£æ³•

```Java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        TreeNode cur = root;
        while (cur != null && cur != p && cur != q) {
            if (cur.val > p.val && cur.val > q.val) {
                cur = cur.left;
            } else if (cur.val < p.val && cur.val < q.val) {
                cur = cur.right;
            } else {
                return cur;
            }
        }
        return cur;
    }
}
```

## æ’å…¥ç»“ç‚¹

### äºŒå‰æœç´¢æ ‘ä¸­çš„æ’å…¥æ“ä½œ

[leetcode.cn/problems/insert-into-a-binary-search-tree/descriptio...](https://leetcode.cn/problems/insert-into-a-binary-search-tree/description/)

> ç»™å®šäºŒå‰æœç´¢æ ‘ï¼ˆBSTï¼‰çš„æ ¹èŠ‚ç‚¹ `root`â€‹ å’Œè¦æ’å…¥æ ‘ä¸­çš„å€¼ `value`â€‹ ï¼Œå°†å€¼æ’å…¥äºŒå‰æœç´¢æ ‘ã€‚ è¿”å›æ’å…¥åäºŒå‰æœç´¢æ ‘çš„æ ¹èŠ‚ç‚¹ã€‚ è¾“å…¥æ•°æ® **ä¿è¯** ï¼Œæ–°å€¼å’ŒåŸå§‹äºŒå‰æœç´¢æ ‘ä¸­çš„ä»»æ„èŠ‚ç‚¹å€¼éƒ½ä¸åŒã€‚
>
> **æ³¨æ„**ï¼Œå¯èƒ½å­˜åœ¨å¤šç§æœ‰æ•ˆçš„æ’å…¥æ–¹å¼ï¼Œåªè¦æ ‘åœ¨æ’å…¥åä»ä¿æŒä¸ºäºŒå‰æœç´¢æ ‘å³å¯ã€‚ ä½ å¯ä»¥è¿”å› **ä»»æ„æœ‰æ•ˆçš„ç»“æœ** ã€‚

* å¦‚æœä¸è€ƒè™‘ç»´æŒæ ‘çš„å¹³è¡¡ï¼Œç›´æ¥æ’å…¥åˆ°æœç´¢çš„ç»ˆç‚¹å³å¯
* è€ƒè™‘æ ‘çš„å¹³è¡¡ï¼Œåˆ™éœ€è¦å®ç°å¹³è¡¡æ ‘

```Java
class Solution {
    public TreeNode insertIntoBST(TreeNode root, int val) {
        return insert(root, val);
    }

    private TreeNode insert(TreeNode root, int val) {
        if (root == null) {     // æ‰¾åˆ°æ’å…¥ç»“ç‚¹ä½ç½®
            return new TreeNode(val);
        }

        if (root.val > val) {
            root.left = insert(root.left, val);
        } else if (root.val < val) {
            root.right = insert(root.right, val);
        }
        return root;
    }
}
```

## åˆ é™¤ç»“ç‚¹

### åˆ é™¤äºŒå‰æœç´¢æ ‘ä¸­çš„ç»“ç‚¹

[leetcode.cn/problems/delete-node-in-a-bst/description/](https://leetcode.cn/problems/delete-node-in-a-bst/description/)

> ç»™å®šä¸€ä¸ªäºŒå‰æœç´¢æ ‘çš„æ ¹èŠ‚ç‚¹ **root**  å’Œä¸€ä¸ªå€¼ **key**ï¼Œåˆ é™¤äºŒå‰æœç´¢æ ‘ä¸­çš„ **key** å¯¹åº”çš„èŠ‚ç‚¹ï¼Œå¹¶ä¿è¯äºŒå‰æœç´¢æ ‘çš„æ€§è´¨ä¸å˜ã€‚è¿”å›äºŒå‰æœç´¢æ ‘ï¼ˆæœ‰å¯èƒ½è¢«æ›´æ–°ï¼‰çš„æ ¹èŠ‚ç‚¹çš„å¼•ç”¨ã€‚
>
> ä¸€èˆ¬æ¥è¯´ï¼Œåˆ é™¤èŠ‚ç‚¹å¯åˆ†ä¸ºä¸¤ä¸ªæ­¥éª¤ï¼š
>
> 1. é¦–å…ˆæ‰¾åˆ°éœ€è¦åˆ é™¤çš„èŠ‚ç‚¹ï¼›
> 2. å¦‚æœæ‰¾åˆ°äº†ï¼Œåˆ é™¤å®ƒã€‚

1. æ²¡æœ‰æ‰¾åˆ°è¦åˆ é™¤çš„ç»“ç‚¹

    1. ä¸åšæ“ä½œ
2. å·¦ç©ºï¼Œå³ç©ºï¼ˆå¶å­ç»“ç‚¹ï¼‰

    1. ç›´æ¥åˆ é™¤å³å¯
3. å·¦éç©ºï¼Œå³ç©º

    1. çˆ¶ç»“ç‚¹æŒ‡å‘å·¦å­ç»“ç‚¹
4. å·¦ç©ºï¼Œå³éç©º

    1. çˆ¶ç»“ç‚¹æŒ‡å‘å³å­ç»“ç‚¹
5. å·¦éç©ºï¼Œå³éç©º

    1. å·¦å­©å­æˆ–å³å­©å­ç»§ä½
    2. å‡è®¾æ˜¯å³å­©å­ç»§ä½ã€‚åˆ é™¤çˆ¶ç»“ç‚¹åï¼Œéœ€è¦ä¸ºçˆ¶ç»“ç‚¹çš„å·¦å­æ ‘å¯»æ‰¾æ–°çš„çˆ¶ç»“ç‚¹ï¼Œè€Œå³å­©å­çš„å·¦å­©å­å°±æ˜¯çˆ¶ç»“ç‚¹çš„ä¸‹ä¸€ä¸ªç»“ç‚¹ï¼ˆåœ¨å¤§å°ä¸Šï¼‰ï¼Œæ‰€ä»¥å¯ä»¥å°†å·¦å­æ ‘ç§»åˆ°å³å­©å­çš„å·¦å­©å­ä¸‹æ–¹

å·²ç»åŒ…å«äº†åˆ é™¤rootçš„æƒ…å†µ

```Java
class Solution {
    public TreeNode deleteNode(TreeNode root, int key) {
        return delete(root, key);
    }

    private TreeNode delete(TreeNode root, int key) {
        if (root == null) {     // æ²¡æœ‰æ‰¾åˆ°éœ€è¦åˆ é™¤çš„ç»“ç‚¹
            return null;
        }
        if (root.val == key) {  // æ‰¾åˆ°è¦åˆ é™¤çš„ç»“ç‚¹
            if (root.left == null && root.right == null) {  // å·¦ç©ºå³ç©º
                return null;    // å°†çˆ¶ç»“ç‚¹çš„å­ç»“ç‚¹å˜ä¸ºnull
            } else if (root.left == null && root.right != null) {   // å·¦ç©ºå³ä¸ç©º
                return root.right;
            } else if (root.left != null && root.right == null) {   // å·¦ä¸ç©ºå³ç©º
                return root.left;
            } else {    // å·¦ä¸ç©ºå³ä¸ç©ºï¼Œä»¤å³å­©å­ç»§ä½
                TreeNode cur = root.right;
                while (cur.left != null) {
                    cur = cur.left;
                }
                cur.left = root.left;   // å˜æˆäº†å·¦ç©ºå³ä¸ç©º
                return root.right;
            }
        } 
        // é€’å½’æ‰¾è¦åˆ é™¤çš„ç»“ç‚¹
        if (root.val < key) {
            root.right = delete(root.right, key);
        } else {
            root.left = delete(root.left, key);
        }
        return root;
    }
}
```

### ä¿®å‰ªäºŒå‰æœç´¢æ ‘

[leetcode.cn/problems/trim-a-binary-search-tree/description/](https://leetcode.cn/problems/trim-a-binary-search-tree/description/)

> ç»™ä½ äºŒå‰æœç´¢æ ‘çš„æ ¹èŠ‚ç‚¹ `root`â€‹ ï¼ŒåŒæ—¶ç»™å®šæœ€å°è¾¹ç•Œ`low`â€‹ å’Œæœ€å¤§è¾¹ç•Œ `high`â€‹ã€‚é€šè¿‡ä¿®å‰ªäºŒå‰æœç´¢æ ‘ï¼Œä½¿å¾—æ‰€æœ‰èŠ‚ç‚¹çš„å€¼åœ¨`[low, high]`â€‹ä¸­ã€‚ä¿®å‰ªæ ‘ **ä¸åº”è¯¥** æ”¹å˜ä¿ç•™åœ¨æ ‘ä¸­çš„å…ƒç´ çš„ç›¸å¯¹ç»“æ„ (å³ï¼Œå¦‚æœæ²¡æœ‰è¢«ç§»é™¤ï¼ŒåŸæœ‰çš„çˆ¶ä»£å­ä»£å…³ç³»éƒ½åº”å½“ä¿ç•™)ã€‚ å¯ä»¥è¯æ˜ï¼Œå­˜åœ¨ **å”¯ä¸€çš„ç­”æ¡ˆ** ã€‚
>
> æ‰€ä»¥ç»“æœåº”å½“è¿”å›ä¿®å‰ªå¥½çš„äºŒå‰æœç´¢æ ‘çš„æ–°çš„æ ¹èŠ‚ç‚¹ã€‚æ³¨æ„ï¼Œæ ¹èŠ‚ç‚¹å¯èƒ½ä¼šæ ¹æ®ç»™å®šçš„è¾¹ç•Œå‘ç”Ÿæ”¹å˜ã€‚

```Java
class Solution {
    public TreeNode trimBST(TreeNode root, int low, int high) {
        return traversal(root, low, high);
    }

    private TreeNode traversal(TreeNode root, int low, int high) {
        if (root == null) {
            return null;
        }
        if (root.val < low) {   // å°äºæœ€å°è¾¹ç•Œï¼Œè¦æ³¨æ„rootçš„å³å­æ ‘å¯èƒ½è¿˜æœ‰ç»“ç‚¹ä¸éœ€è¦è¢«åˆ é™¤
            return traversal(root.right, low, high);
        } else if (root.val > high) {   // å¤§äºæœ€å¤§è¾¹ç•Œï¼Œrootçš„å·¦å­æ ‘ä¸­å¯èƒ½è¿˜æœ‰ç»“ç‚¹ä¸éœ€è¦è¢«åˆ é™¤
            return traversal(root.left, low, high);
        }
  
        root.left = traversal(root.left, low, high);	// è¿”å›å¤„ç†å®Œæ¯•åçš„å·¦å­æ ‘çš„æ ¹ç»“ç‚¹
        root.right = traversal(root.right, low, high);	// è¿”å›å¤„ç†å®Œæ¯•åçš„å³å­æ ‘çš„æ ¹ç»“ç‚¹
        return root;
    }
}
```

## æ„é€ /è½¬æ¢æ ‘

### å°†æœ‰åºæ•°ç»„è½¬æ¢ä¸ºäºŒå‰æœç´¢æ ‘

[leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/...](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/description/)

> ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ `nums`â€‹ ï¼Œå…¶ä¸­å…ƒç´ å·²ç»æŒ‰ **å‡åº** æ’åˆ—ï¼Œè¯·ä½ å°†å…¶è½¬æ¢ä¸ºä¸€æ£µ**å¹³è¡¡äºŒå‰æœç´¢æ ‘**ã€‚

å› ä¸ºå·²ç»å‡åºæ’å¥½äº†ï¼Œæ‰€ä»¥ç›´æ¥äºŒåˆ†è¿›è¡Œæ„å»ºå³å¯

```Java
class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        return halfBuild(nums, 0, nums.length - 1);
    }

    private TreeNode halfBuild(int[] nums, int left, int right) {
        if (left > right) {
            return null;
        }
        int mid = (left + right) / 2;
        TreeNode root = new TreeNode(nums[mid]);
        root.left = halfBuild(nums, left, mid - 1);
        root.right = halfBuild(nums, mid + 1, right);
        return root;
    }
}
```

### æŠŠäºŒå‰æœç´¢æ ‘è½¬æ¢ä¸ºç´¯åŠ æ ‘

[leetcode.cn/problems/convert-bst-to-greater-tree/description/](https://leetcode.cn/problems/convert-bst-to-greater-tree/description/)

> ç»™å‡ºäºŒå‰  **æœç´¢**  æ ‘çš„æ ¹èŠ‚ç‚¹ï¼Œè¯¥æ ‘çš„èŠ‚ç‚¹å€¼å„ä¸ç›¸åŒï¼Œè¯·ä½ å°†å…¶è½¬æ¢ä¸ºç´¯åŠ æ ‘ï¼ˆGreater Sum Treeï¼‰ï¼Œä½¿æ¯ä¸ªèŠ‚ç‚¹ `node`â€‹ çš„æ–°å€¼ç­‰äºåŸæ ‘ä¸­å¤§äºæˆ–ç­‰äº `node.val`â€‹ çš„å€¼ä¹‹å’Œã€‚

* ä»¥**å³æ ¹å·¦**çš„ååºéå†é¡ºåºè¿›è¡Œéå†
* è®°å½•æ€»å’Œ

  * å®šä¹‰å…¨å±€å˜é‡
  * ç”¨åŒæŒ‡é’ˆ

#### å…¨å±€å˜é‡è§£æ³•

```Java
class Solution {
    private int sum;

    public TreeNode convertBST(TreeNode root) {
        sum = 0;
        return traversal(root);
    }

    private TreeNode traversal(TreeNode cur) {
        if (cur == null) {
            return null;
        }
    
        TreeNode root = new TreeNode();
        root.right = traversal(cur.right);
        sum += cur.val;
        root.val = sum;
        root.left = traversal(cur.left);
        return root;
    }
}
```

#### åŒæŒ‡é’ˆè§£æ³•

```Java
class Solution {
    private TreeNode pre;
    public TreeNode convertBST(TreeNode root) {
        pre = null;
        return traversal(root);
    }

    private TreeNode traversal(TreeNode cur) {
        if (cur == null) {
            return null;
        }
    
        TreeNode root = new TreeNode(cur.val);
        root.right = traversal(cur.right);
        if (pre != null) {
            root.val += pre.val;
        }
        pre = root;
        root.left = traversal(cur.left);
        return root;
    }
}
```

## å¹³è¡¡äºŒå‰æœç´¢æ ‘

### çº¢é»‘æ ‘
